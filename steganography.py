# -*- coding: utf-8 -*-
"""Steganography

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YS77dhE0aiOvkFPND9ZvhnDoUuvSf03E
"""

class Steganography():

  def __init__(self, image, cipher, filename):
    self.img = image
    self.data = cipher
    self.pixel = 5.5
    self.list1 = [ ]
    self.filename = filename
    import numpy as np
    import cv2 as cv
    self.np = np
    self.cv = cv

  def BinaryTointeger(binary):  
      binary1 = binary  
      decimal, i, n = 0, 0, 0
      while(binary != 0):  
          dec = binary % 10
          decimal = decimal + dec * pow(2, i)  
          binary = binary//10
          i += 1
      return (decimal)     


  def message2binary(self):

    if type(self.data) == str:
      result= ''.join([ format(ord(i), "08b") for i in self.data ])

    elif type(self.data) == bytes or type(self.data) == self.np.ndarray:
      result= [ format(i, "08b") for i in self.data ]
      
    elif type(self.data) == int or type(self.data) == self.np.uint8:
      result=format(self.data, "08b")

    else:
      raise TypeError("Input type is not supported")
      
    return result

  def message2binaryA(self):
    if type(self.pixel) == str:
      result= ''.join([ format(ord(i), "08b") for i in self.pixel ])
      
    elif type(self.pixel) == bytes or type(self.pixel) == self.np.ndarray:
      result= [ format(i, "08b") for i in self.pixel ]
      
    elif type(self.pixel) == int or type(self.pixel) == self.np.uint8:
      result=format(self.pixel, "08b")

    else:
      raise TypeError("Input type is not supported")
      
    return result

  def encode_data(self):   
    if (len(self.data) == 0): 
      raise ValueError('Data is empty')
  
    
    no_bytes=(self.img.shape[0] * self.img.shape[1] * 3) // 8
    
    #print("Maximum bytes to encode:", no_bytes)
    
    if(len(self.data)>no_bytes):
        raise ValueError("Error encountered Insufficient bytes, Need Bigger Image or give Less Data !!")
    
    # Using the below as delimeter
    self.data +='*****'    
    
    data_binary=self.message2binary()
    #print(data_binary)
    data_len=len(data_binary)
    
    #print("The Length of Binary data",data_len)
    
    data_index = 0
    
    for i in self.img:
        for self.pixel in i:
            
          r, g, b = self.message2binaryA()
         # print(r)
         # print(g)
         # print(b)
          # print(pixel)
          if data_index < data_len:
              # hiding the data into LSB(Least Significant Bit) of Red Pixel
#               print("Original Binary",r)
              # print("The old pixel",pixel[0])
              self.pixel[0] = int(r[:-1] + data_binary[data_index], 2) #changing to binary after overwrriting the LSB bit of Red Pixel
#               print("Changed binary",r[:-1] + data_binary[data_index])
              
              data_index += 1
              self.list1.append(self.pixel[0])

          if data_index < data_len:
             # hiding the data into LSB of Green Pixel
              self.pixel[1] = int(g[:-1] + data_binary[data_index], 2) #changing to binary after overwrriting the LSB bit of Green Pixel
              data_index += 1
              self.list1.append(self.pixel[1])

          if data_index < data_len:
              # hiding the data into LSB of  Blue Pixel
              self.pixel[2] = int(b[:-1] + data_binary[data_index], 2) #changing to binary after overwrriting the LSB bit of Blue pixel
              data_index += 1
              self.list1.append(self.pixel[2])

              # if data is encoded, just breaking out of the Loop
          if data_index >= data_len:
              break

    self.cv.imwrite(self.filename, self.img)
    print("Encoded the data successfully and the image is successfully saved as ", self.filename)

    return self.img

#import cv2
#image=cv2.imread("00002.jpg")
#image.shape

#modifiedImg = Steganography(image, "3871E275B6CD")

#modifiedImage = modifiedImg.encode_data()

import numpy as np

#modifiedImage.shape

